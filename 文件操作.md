# 文件操作

## 文件基本介绍

![image-20211013193700486](C:\Users\86157\AppData\Roaming\Typora\typora-user-images\image-20211013193700486.png)

## os.File

os包下的File结构体所属方法，包含了对文件的操作

### 1. 打开和关闭文件

- open函数和属于文件指针的close方法，需要返回文件指针或错误

```go
func Open(name string) (*File, error){
    //源码
}
func (f *File) Close() error{
    //源码
}
```

- 更一般的打开或关闭函数（OpenFile函数）

```go
func OpenFile(name string, flag int, perm FileMode) (*File, error){
    //flag表示打开方式，os包下的常量（可查看），FileMode在windows系统下不起作用，只有在其他系统才会发挥作用
    /*
    常量如下：
    O_RDONLY int = syscall.O_RDONLY // 只读模式打开文件
    O_WRONLY int = syscall.O_WRONLY // 只写模式打开文件
    O_RDWR   int = syscall.O_RDWR   // 读写模式打开文件
    O_APPEND int = syscall.O_APPEND // 写操作时将数据附加到文件尾部
    O_CREATE int = syscall.O_CREAT  // 如果不存在将创建一个新文件
    O_EXCL   int = syscall.O_EXCL   // 和O_CREATE配合使用，文件必须不存在
    O_SYNC   int = syscall.O_SYNC   // 打开文件用于同步I/O
    O_TRUNC  int = syscall.O_TRUNC  // 如果可能，打开时清空文件
	*/
}
```



```go
	file, _ :=os.OpenFile("d:/2.txt",os.O_RDWR|os.O_CREATE,fs.ModeSetgid)
	writer:=bufio.NewWriter(file)
	defer file.Close()
	for {
		var a string
		_, err := fmt.Scanln(&a)
		if err != nil {
			panic("input error!")
		}
		_, err = writer.WriteString(a)
		if err != nil {
			panic("write error!")
		}
		if a=="#" {
			break
		}
	}
	//调用Flush进行流的刷新(一定要注意流的刷新)
	writer.Flush()
}
```



### 2. 读入文件

- 采用具备缓冲区的bufio.NewReader()函数，通过*Reader所属ReadString方法读取文件（会有乱码问题）

  ```go
  file, err :=os.Open("D:/IO流实验文件夹/txt/3.txt")
  	if err != nil{
  		fmt.Println("open file err=", err)
  	}
  	// 当函数退出时, 要及时关闭file句柄, 否则会有内存泄漏
  	defer file.Close()
  	// 创建一个 *Reader, 是带缓冲区  defaultBufSize = 4096字节(默认)
  	reader := bufio.NewReader(file)
  	// 循环读取文件内容
  	for {
  		str, err := reader.ReadString('\n')  // 读到一个换行就结束
  		if err == io.EOF{   // io.EOF 表示读取到了文件的末尾
  			break
  		}
  		// 输出内容
  		fmt.Print(str)
  	}
  	fmt.Println("文件读取结束.....")
  ```

- 采用ioutil包下的ReadFile函数进行一次性读取文件内容（缺陷：不适合读取较大的文件）值得注意的是，ReadFile函数对文件的打开与关闭进行了封装，所以就无需在进行显示的打开与关闭操作

```go
file:="D:/IO流实验文件夹/txt/3.txt"
content, err := ioutil.ReadFile(file)
if err != nil{
   fmt.Printf("read file err=%v\n", err)
}
// 把读取到的内容显示到终端
fmt.Printf("%v", string(content))  // 若不使用String  默认是[]byte类型
```

### 3. 写入文件

- 采用具备缓冲区的bufio.NewWriter()函数，通过*Writer所属WriteString()方法读取文件,使用缓冲区的程序，需要在函数结尾需要调用flush刷新流

```go
file, _ :=os.OpenFile("d:/2.txt",os.O_RDWR|os.O_CREATE,fs.ModeSetgid)
writer:=bufio.NewWriter(file)
defer file.Close()
for {
   var a string
   _, err := fmt.Scanln(&a)
   if err != nil {
      panic("input error!")
   }
   _, err = writer.WriteString(a)
   if err != nil {
      panic("write error!")
   }
   if a=="#" {
      break
   }
}
//调用Flush进行流的刷新(一定要注意流的刷新)
writer.Flush()
```

- 采用ioutil包下的ReadFile函数进行一次性读取文件内容（缺陷：不适合读取较大的文件）值得注意的是，ReadFile函数对文件的打开与关闭进行了封装，所以就无需在进行显示的打开与关闭操作（注意如果没有文件，也会创建文件）

```go
/*//创建文件对象
	file1, err := os.OpenFile("d:/1.txt",os.O_RDONLY,fs.ModeDevice)
	defer func(file1 *os.File) {
		err := file1.Close()
		if err != nil {
			panic("close file1 error!")
		}
	}(file1)
	if err != nil {
		panic("open file1 error!")
	}
	file2, err := os.OpenFile("d:/2.txt", os.O_WRONLY|os.O_CREATE, fs.ModeDevice)
	defer func(file2 *os.File) {
		err := file2.Close()
		if err != nil {
			panic("close file2 error!")
		}
	}(file2)
	if err != nil {
		panic("open file2 error!")
	}*/
	//实现逻辑
	fileContent, err := ioutil.ReadFile("d:/1.txt")
	if err != nil {
		panic("read error")
	}
	fmt.Print(string(fileContent))
	err = ioutil.WriteFile("d:/3.txt", fileContent, 0666)//没文件也会在目录下创建文件
	if err != nil {
		panic("write error")
	}
```

### 4. 拷贝文件

文件拷贝copy函数可以实现对任意形式文件（视频，音乐，文档等）进行计算机内部数据迁移

```go
srcFile:="D:/IO流实验文件夹/美女图片/2.jpg"
	dstFile:="d:/2.jpg"
	_, err := copyFile(srcFile, dstFile)
	if err != nil {
		fmt.Printf("%v",err)
	}else {
		fmt.Print("拷贝成功！")
	}
}

func copyFile(srcFile string, dstFile string) (writer int64,err error){
	file1, err := os.Open(srcFile)
	if err != nil {
		panic("srcFile open error!")
	}
	defer func(file1 *os.File) {
		err := file1.Close()
		if err != nil {
			panic("close error!")
		}
	}(file1)
	file2, err := os.OpenFile(dstFile, os.O_CREATE|os.O_WRONLY, fs.ModeDevice)
	if err != nil {
		panic("file2 open error")
	}
	defer func(file2 *os.File) {
		err := file2.Close()
		if err != nil {
			panic(err)
		}
	}(file2)
	return io.Copy(file1,file2)
```

### 5. stat函数判断文件存在性

![image-20211014233303190](C:\Users\86157\AppData\Roaming\Typora\typora-user-images\image-20211014233303190.png)
