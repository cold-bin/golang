# `gorm`入门+进阶

## 一、`orm`

### 1. [ORM](https://so.csdn.net/so/search?q=ORM&spm=1001.2101.3001.7020)简介

对象关系映射（`Object Relational Mapping`，简称`ORM`）模式是一种为了解决[面向对象](https://so.csdn.net/so/search?q=面向对象&spm=1001.2101.3001.7020)与关系数据库存在的互不匹配的现象的技术。简单的说，ORM是通过使用描述对象和数据库之间映射的元数据，将程序中的对象自动持久化到关系数据库中。那么，到底如何实现持久化呢？一种简单的方案是采用硬编码方式，为每一种可能的数据库访问操作提供单独的方法。

这种方案存在以下不足： 
    1. 持久化层缺乏弹性。一旦出现业务需求的变更，就必须修改持久化层的接口 
        2. 持久化层同时与域模型与[关系数据库](https://so.csdn.net/so/search?q=关系数据库&spm=1001.2101.3001.7020)模型绑定，不管域模型还是关系数据库模型发生变化，毒药修改持久化曾的相关程序代码，增加了软件的维护难度。 

ORM提供了实现持久化层的另一种模式，它采用映射[元数据](https://so.csdn.net/so/search?q=元数据&spm=1001.2101.3001.7020)来描述对象关系的映射，使得ORM中间件能在任何一个应用的业务逻辑层和数据库层之间充当桥梁。Java典型的ORM中间有:`Hibernate`,`ibatis`,`speedframework`。 
ORM的方法论基于三个核心原则：

- 简单：以最基本的形式建模数据。

- 传达性：数据库结构被任何人都能理解的语言文档化。
- 精确性：基于数据模型创建正确标准化了的结构。

### 2. ORM概念 

让我们从O/R开始。字母O起源于"对象"(Object),而R则来自于"关系"(Relational)。几乎所有的程序里面，都存在对象和关系数据库。在业务逻辑层和用户界面层中，我们是面向对象的。当对象信息发生变化的时候，我们需要把对象的信息保存在关系数据库中。 

当你开发一个应用程序的时候(不使用`O/R Mapping`),你可能会写不少数据访问层的代码，用来从数据库保存，删除，读取对象信息等等。你在DAL中写了很多的方法来读取对象数据，改变状态对象等等任务。而这些代码写起来总是重复的。 

ORM解决的主要问题是对象关系的映射。域模型和关系模型分别是建立在概念模型的基础上的。域模型是面向对象的，而关系模型是面向关系的。**一般情况下，一个持久化类(结构体)和一个表对应，类（结构体）的每个实例对应表中的一条记录，类的每个属性对应表的每个字段。** 

ORM技术特点： 

提高了开发效率。由于ORM可以自动对Entity对象与数据库中的Table进行字段与属性的映射，所以我们实际可能已经不需要一个专用的、庞大的数据访问层。 

ORM提供了对数据库的映射，不用`sql`直接编码，能够像操作对象一样从数据库获取数据。

### 3. ORM优缺点 

ORM的缺点是会牺牲程序的执行效率和会固定思维模式。 
从系统结构上来看,采用ORM的系统一般都是多层系统，系统的层次多了，效率就会降低。ORM是一种完全的面向对象的做法，而面向对象的做法也会对性能产生一定的影响。 

在我们开发系统时，一般都有性能问题。性能问题主要产生在算法不正确和与数据库不正确的使用上。ORM所生成的代码一般不太可能写出很高效的算法，在数据库应用上更有可能会被误用，主要体现在对持久对象的提取和和数据的加工处理上，如果用上了ORM,程序员很有可能将全部的数据提取到内存对象中，然后再进行过滤和加工处理，这样就容易产生性能问题。 
在对对象做持久化时，ORM一般会持久化所有的属性，有时，这是不希望的。 
但ORM是一种工具，工具确实能解决一些重复，简单的劳动。这是不可否认的。但我们不能指望工具能一劳永逸的解决所有问题，有些问题还是需要特殊处理的，但需要特殊处理的部分对绝大多数的系统，应该是很少的。

 

## 二、`ORM`的使用原因

什么是“持久化”
持久（Persistence），即把数据（如内存中的对象）保存到可永久保存的存储设备中（如磁盘）。持久化的主要应用是将内存中的数据存储在关系型的数据库中，当然也可以存储在磁盘文件中、XML数据文件中等等。
什么是“持久层”
持久层（Persistence Layer），即专注于实现数据持久化应用领域的某个特定系统的一个逻辑层面，将数据使用者和数据实体相关联。

什么是ORM
即`Object-Relationl Mapping`，它的作用是在关系型数据库和对象之间作一个映射，这样，我们在具体的操作数据库的时候，就不需要再去和复杂的SQL语句打交道，只要像平时操作对象一样操作它就可以了 。

为什么要做持久化和ORM设计(重要)
在目前的企业应用系统设计中，MVC，即 Model（模型）- View（视图）- Control（控制）为主要的系统架构模式。MVC 中的 Model 包含了复杂的业务逻辑和数据逻辑，以及数据存取机制（如 JDBC的连接、SQL生成和Statement创建、还有ResultSet结果集的读取等）等。将这些复杂的业务逻辑和数据逻辑分离，以将系统的紧耦合关系转化为松耦合关系（即解耦合），是降低系统耦合度迫切要做的，也是持久化要做的工作。MVC 模式实现了架构上将表现层（即View）和数据处理层（即Model）分离的解耦合，而持久化的设计则实现了数据处理层内部的业务逻辑和数据逻辑分离的解耦合。而 ORM 作为持久化设计中的最重要也最复杂的技术，也是目前业界热点技术。

简单来说，按通常的系统设计，使用 JDBC 操作数据库，业务处理逻辑和数据存取逻辑是混杂在一起的。
一般基本都是如下几个步骤：
1、建立数据库连接，获得 Connection 对象。
2、根据用户的输入组装查询 SQL 语句。
3、根据 SQL 语句建立 Statement 对象 或者 PreparedStatement 对象。
4、用 Connection 对象执行 SQL语句，获得结果集 ResultSet 对象。
5、然后一条一条读取结果集 ResultSet 对象中的数据。
6、根据读取到的数据，按特定的业务逻辑进行计算。
7、根据计算得到的结果再组装更新 SQL 语句。
8、再使用 Connection 对象执行更新 SQL 语句，以更新数据库中的数据。
7、最后依次关闭各个 Statement 对象和 Connection 对象。

由上可看出代码逻辑非常复杂，这还不包括某条语句执行失败的处理逻辑。其中的业务处理逻辑和数据存取逻辑完全混杂在一块。而一个完整的系统要包含成千上万个这样重复的而又混杂的处理过程，假如要对其中某些业务逻辑或者一些相关联的业务流程做修改，要改动的代码量将不可想象。另一方面，假如要换数据库产品或者运行环境也可能是个不可能完成的任务。而用户的运行环境和要求却千差万别，我们不可能为每一个用户每一种运行环境设计一套一样的系统。
所以就要将一样的处理代码即业务逻辑和可能不一样的处理即数据存取逻辑分离开来，另一方面，关系型数据库中的数据基本都是以一行行的数据进行存取的，而程序运行却是一个个对象进行处理，而目前大部分数据库驱动技术（如ADO.NET、JDBC、ODBC等等）均是以行集的结果集一条条进行处理的。所以为解决这一困难，就出现 ORM 这一个对象和数据之间映射技术。

举例来说，比如要完成一个购物打折促销的程序，用 ORM 思想将如下实现（引自《深入浅出Hibernate》）：
业务逻辑如下：

```java
public Double calcAmount(String customerid, double amount)
{
  // 根据客户ID获得客户记录
  Customer customer = CustomerManager.getCustomer(custmerid);
  // 根据客户等级获得打折规则
  Promotion promotion = PromotionManager.getPromotion(customer.getLevel());
  // 累积客户总消费额，并保存累计结果
  customer.setSumAmount(customer.getSumAmount().add(amount);
  CustomerManager.save(customer);
  // 返回打折后的金额
  return amount.multiply(protomtion.getRatio());
}
```

这样代码就非常清晰了，而且与数据存取逻辑完全分离。设计业务逻辑代码的时候完全不需要考虑数据库JDBC的那些千篇一律的操作，而将它交给 `CustomerManager` 和 `PromotionManager` 两个类去完成。这就是一个简单的 ORM 设计，实际的 ORM 实现[框架](https://so.csdn.net/so/search?q=框架&spm=1001.2101.3001.7020)比这个要复杂的多

## 三、`gorm`入门及其使用

### 1. `golang`结构体字段类型限制

![go与mysql数据类型匹配](https://img-blog.csdnimg.cn/20190925191722200.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM0NzM1NTkw,size_16,color_FFFFFF,t_70)

![在这里插入图片描述](https://img-blog.csdnimg.cn/20190925191802646.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM0NzM1NTkw,size_16,color_FFFFFF,t_70)

### 2. `gorm`基础学习

https://gorm.io/zh_CN/docs/query.html