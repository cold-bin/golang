# `Restful API`

[TOC]

**`REST`的约束条件有**：

1. 统一接口
2. 无状态
3. 缓存
4. 客户端-服务器
5. 分层系统
6. 按需代码（可选）

其中，统一接口是最直观、也是应用中偏差最大的地方，下面会重点讲解。其余各约束条件则简单讲解。

### 1. 统一接口

统一接口其实体现在多个方面：

- 资源URI
- 请求参数
- 请求方法
- 返回码
- 返回内容
- ……

#### 1) 资源URI

`RESTful`架构是基于资源的架构，所操作的一切对象都是资源。因此，需要明确地定位一个资源，而URI技术正好满足这个需求，所以`REST`中通过`URI`来定位资源。

资源是一个对象，所以`URI`中一般只能包含名词（一般是复数），不应该包含动词。**当需要定位具体的资源时，`URI`中一般包含资源的唯一`ID`**。例如：

```crystal
// 满足REST架构风格的URI
http://www.example.com/books    // 所有书籍的资源集合
http://www.example.com/books/123    // ID为123的书籍资源

// 不满足REST架构风格的URI
http://www.example.com/books/query
http://www.example.com/buy
```

#### 2) 请求参数

因为`REST`需要通过`URI`来唯一定位某个（或某种）资源，所以查询资源时，各种资源`ID`一般是放在`URI`里面，而不是放在请求参数里面。**请求参数中一般放过滤条件分页信息等字段**。例如：

```awk
// 满足REST架构风格的URI
http://www.example.com/books/123    // ID为123的书籍资源
http://www.example.com/Fielding/books?page=1&per_page=10    // 作者为Fielding的前10本书籍资源集合

// 不满足REST架构风格的URI
http://www.example.com/books?id=123
http://www.example.com/books?author=Fielding
```

#### 3) 请求方法

`REST`约定用`GET/POST/PUT/DELETE`等请求方法来进行`CURD`操作。但是否使用了`GET/POST/PUT/DELETE`，并不能作为评判一个系统是否符合REST架构风格的标准。例如，有些系统所有接口都使用GET和POST方法，如果该系统只提供查询和创建操作，那么可能是符合`REST`架构风格的；但如果该系统还提供修改、删除操作，则该系统不符合REST架构风格。

有些人认为`GET/POST/PUT/DELETE`跟CURD是一对一的关系，其实不是。

具体的说，各请求方法如下：

- `GET`：用于**查询资源**。
- `POST`：用于**创建资源**。`POST`方法创建资源的URI由服务器决定，如：`POST` [`http://www.example.com/Fieldi...`](https://link.segmentfault.com/?enc=ECPnytauHx%2F3sNhYe5SJiw%3D%3D.POZvqOoMENraiDP0%2FMVeW9GPqpIXMPlstCCBSjmAxt8b9GC6rIYY4QIEXQh49pfS)，则是在`ID`为123的`book`资源下创建一个某类别资源，如书的评论等，评论的`URI`也会包含一个服务器生成的ID。
- `PUT`：用于创建或修改资源。`PUT`方法创建资源的URI由客户端决定，如：`PUT` [`http://www.example.com/Fieldi...`](https://link.segmentfault.com/?enc=NI6RC0SB74RrREzj78LQNQ%3D%3D.v8Hza2NUGMmuxdUvF88MYApfLc1ctvOlwXlmxpaiXG9Kxp44qn1aEQLcbkBhkzHA)，当`ID`为123的book**资源存在时，将进行修改操作；否则进行创建操作**。
- `DELETE`：用于**删除资源**。

另外，还有其他较少用的请求方法，需要注意的是可能部分浏览器不支持。

- `HEAD`：用于获取资源的元信息。`HEAD`方法与`GET`方法类似，都可以查询资源的元信息（放在`HTTP Response`的`Header`），但不会返回资源的表述。例如用于判断资源是否存在。
- `PATCH`：用于修改资源。**与`PUT`方法不同的是，`PATCH`方法只传输改动的部分资源表述，而`PUT`方法需要传输完整的资源表述。**

#### 4) 返回码

`REST`使用`HTTP`返回码来表示请求的结果。如果使用规范的`REST API`，那么根据`HTTP`返回码就能确定很多信息。常见的`HTTP`返回码如下：

- `200（OK）`：表示请求成功。
- `201（Created）`：表示资源创建成功。
- `204（No content）`：表示资源为空。
- `301（Moved Permanently）`：表示资源的URI已永久性更改，需要在响应内容中获取新的URI。
- `302（Moved Temporarily）`：表示资源的URI已临时性更改，需要在响应内容中获取新的URI。
- `400（Bad Request）`：表示请求有问题，如参数错误等。
- `403（Forbidden）`：表示鉴权不通过，没有权限访问该资源。
- `404（Not Found）`：表示资源不存在。
- `405（Method Not Allowed）`：表示该资源不支持当前的请求方法。
- `409（Conflict）`：表示当前请求的某前置条件不符合。
- `500（Internal Server Error）`：通用内部错误。
- `502（Bad Gateway）`：网关错误，从上游服务器收到无效响应。
- `504（Gateway Timeout）`：网关超时，在预期时间内没有收到上游服务器的响应。
- ……

还有其他`HTTP`返回码，可以参考`HTTP`标准。

只要使用了规范的`REST`架构风格，那么就可以根据`HTTP`的标准，做出明确的相应处理，无需另外制定私有协议了。既减少了私有协议的兼容性问题，又能作为标准适用于所有的`RESTful`架构。

#### 5) 返回内容

`REST API`的返回内容应该是资源的表述。

前面说过，同一个资源可以有多种不同格式的表述，如`json`格式和`xml`格式，所以返回内容应该是自描述的。也就是说，在`HTTP`响应的`Header`中，必须包含`Content-type`属性，如`application/json`、`application/xml`、`text/html`等。

另外，`REST`是“可编程”的Web服务，也就是说，程序可以根据`REST API`的返回内容，进行下一步的操作。例如，查询`author`资源，下一步可能是要查询该作者著作的`book`资源。所以，如果`author`资源的表述中包含了该作者著作`book`资源的`URI`，则客户端可以进行相应的操作。又如，查询某个地图资源，地图资源的表述中如果包含了各方向的相邻地图资源，则当客户端的鼠标移到屏幕边缘时，就可以获取到该方向上的地图资源了；或者地图资源的表述中包含景点、餐馆等资源`URI`，则可以进行相应的操作。

在表述中包含其他资源的`URI`实现了连通性。连通性可以作为客户端应用状态的状态引擎，引导客户端进行下一步的操作，带来了极大的便利。

#### 6) 其他

统一接口还有其他方面的原则，本文就不细讲了，感兴趣的朋友可以阅读Fielding的论文。

### 2. 无状态

**无状态约束条件是指两次请求之间不存在依赖关系，每一次请求都包含完整的状态信息。这里指的状态是指客户端与服务器之间通信交互的状态，与资源状态无关。**

**举个有状态的例子，为了查工资，需要先登录系统（第一次请求），再输入查询密码（第二次请求）。如果前面两次请求都通过了，那么调用查询接口则可以查询到工资；否则调用查询接口则报未鉴权的错误。查询工资接口的返回结果与前面两次请求的状态是关联的，所以是有状态的服务。**

**而无状态的服务，则直接调用查询工资接口，在请求中（一般在`Header`中）带有鉴权信息，若鉴权通过则可查询到工资，鉴权不通过则报错。该请求不依赖于任何前置请求，称为无状态。**

**REST使用无状态约束条件，确保了请求的独立性和简单性，减少了很多跨请求的状态维护成本。当然，带来的代价是每次请求可能需要传输冗余的信息。**

### 3. 缓存

缓存约束条件主要是用于改善网络的效率。**缓存约束条件要求一个请求的响应中的数据被隐式地或显式地标记为可缓存的或不可缓存的。**如果响应是可缓存的，那么客户端缓存就可以为以后的相同请求重用这个响应的数据，减少了网络交互，提高了效率、可伸缩性和用户感知的性能。

### 4. 客户端-服务器

这个约束条件主要是**分离用户界面和数据存储**，一方面改善用户界面跨平台的可移植性，另一方面简化服务器组件，改善系统的可伸缩性。

### 5. 分层系统

分层系统架构约束条件将架构分为若干层，划定每一层的边界，从而降低每一层设计的复杂度。同时，通过分层，可以抽象底层的异构性，给上层提供统一的接口，简化上层的逻辑。

### 6. 按需代码

按需代码约束条件是指某些场景下，客户端不清楚资源的处理方法，通过向服务器请求相应的处理代码来执行。这样可以简化客户端开发，允许部署后下载功能代码来改善系统的可扩展性。但是，因为传输的是代买，降低了可见性，所以是REST的一个可选的架构约束条件。